> step1 요구사항 구현을 위한 전략

TODO 메뉴 추가

- [x] 메뉴의 이름을 입력 받고 엔터키 입력으로 추가한다.
- [x] 메뉴의 이름을 입력 받고 확인 버튼 클릭으로 추가한다.
- [x]추가되는 메뉴의 마크업은 `<ul id="espresso-menu-list" class="mt-3 pl-0"></ul> 안에 삽입해야 한다.`
- [x] 총 메뉴 갯수를 count하여 상단에 보여준다.
- [x] 메뉴가 추가되고 나면, input은 빈 값으로 초기화한다.
- [x] 사용자 입력값이 빈 값이라면 추가되지 않는다.
- [x] enter키가 아닌 다른 키에서 alert가 뜨지 않는다.

$표시는 html에서 dom element를 가져올 때 관용적으로 많이들 가져온다.
코드가 길어질때 줄어서 쓰기 편하다

form태그가 enter를 쳤을 때 자동으로 전송되는 것을 막아준다.
querySelector: 찾기
addEventListener: 지정한 유형의 이벤트를 대상이 수신할 때마다 호출 함수를 설정한다.

- form이 전송되는 이벤트는 submit이벤트라고 한다.
  preventDefault: 엔터키를 눌렀을 때 막아주는 기능을 한다.

메뉴의 이름을 입력받는 것
querySelector로 input의 id값을 찾아서
keypress라는 함수를 통해 이벤트를 했을때, 이때 사용자가 어떤 값을 입력했는지 찾아야한다.
그것을 이벤트를 함수에서 받아올 수 가 있다.
if문을 통해 사용자가 엔터키를 누르면 event.key를 통해서 사용자가 입력한 이벤트 값을 받아올 수 있다는 조건으로 알아낸다

dom : 자바스크립트를 이용해 html에서 데이터를 가져오고 싶을 때
innerHTML : 코드에 html를 추가하고 싶을 때 쓰는 거
element.insertAdjacentHTML(position,text) : 해당 메서드는 HTML이나 XML같은 특정 텍스트를 파싱하고, 특정 위치에 DOM tree안에 원하는 node들을 추가한다.
이미 사용중인 element는 다시 파싱하지 않는다. 그러므로 element 안에 존재하는 element를 건드리지 않는다. innerHtml보다는 작업이 덜 들고 빠르다

TODO 메뉴 수정

- [x] 메뉴의 수정 버튼클릭 이벤트를 받고, 메뉴수정하는 모달창(prompt)이 뜬다.
- [x] 모달창에서 신규메뉴명을 입력 받고, 확인버튼을 누르면 메뉴가 수정된다.

TODO 메뉴 삭제

- [x] 메뉴 삭제 버튼 클릭 이벤트를 받고, 메뉴 삭제 컨펌(confirm) 모달창이 뜬다.
- [x] 확인 버튼을 클릭하면 메뉴가 삭제된다.
- [x] 총 메뉴 갯수를 count하여 상단에 보여준다.

이벤트 위임 : li태그들이 이벤트가 동작이 되어야하는데
해당 코드가 존재하지 않기 때문에 그 부모인 ul태그에 해당 이벤트를 위임한다.
prompt("사용자에게 전달할 메세지 작성 가능","기본 값")
Element.closest() : 부모 요소 단위로 출발하여 각 요소가 지정한 선택자에 가장 가깝게 조건에 만족한 부모요소가 반환되며, 조건에 만족한 요소가 없으면 null 값을 반환한다.
Element.remove() : 삭제기능을 하는 method

> step2요구사항 - 상태 관리로 메뉴 관리하기

//TODO localStorage Read & Write
//- [x] localStorage에 데이터를 저장한다.
//- [x] 메뉴를 추가할 때
//- [x] 메뉴를 수정할 때
//- [x] 메뉴를 삭제할 때
//- [x] localStorage에 데이터를 console로 읽고 저장된 내역이 화면으로 나타난다.
// -> 페이지 최초로 접근 했을 때 localStorage에 저장된 데이터가 있다면 console에 나타나게끔 구현

//TODO 카테고리별 메뉴판 관리
//- [x] 에스프레소 메뉴판 관리
//- [x] 프라푸치노 메뉴판 관리
//- [x] 블렌디드 메뉴판 관리
//- [x] 티바나 메뉴판 관리
//- [x] 디저트 메뉴판 관리

//TODO 페이지 접근시 최초 데이터 Read & Rendering
//- [x] 페이지에 최초로 접근할 때 localStorage에 에스프레소 메뉴를 읽어온다.
//- [x] 에스프레소 메뉴가 페이지에 나타난다.

//TODO 품절 상태관리
//- [x] 품절 버튼을 추가한다.
//- [x] 품절 버튼을 클릭하면 localStorage에 상태값이 저장된다.
//- [x] 품절된 상태의 상품 품절버튼을 클릭하면 다시 되돌아온다.
//- [x] 클릭이벤트에서 가장 가까운 li태그의 class속성 값에 sold-out을 추가한다.

- localStorage : url별로 사용할 수 있는브라우저에 저장할 수 있는 저장소.
  저장방법 : localStorage.setItem("menu","espresso") 형태로 key 와value의 형태로 사용가능하다.
  사용방법 : localStorage.getItem("menu")형태로 key값만 적어주면 저장된 데이터를 가져올 수 있다.
  특징 :
  - 크롬의 application 탭에서 해당 localStorage url에서 저장된 것을 확인할 수 있다.
  - 문자열 형태로만 저장이 가능하고 object 형태로 관리할 수 없다. 따라서 object(객체)형태를 문자열 형태로 저장하기 위해서 JSON.stringify를 사용한다.
  - JSON.parse : 문자열 형태를 객체형태로 바꿔준다.
  - this.~ 의 형태로 상태를 선언해 준 후 사용한다.
    -this.~이라는 메소드로 선언을 했다면 app.~(); 으로 메소드를 실행시켜준다.
- join("") : "<li>~</li>","<li>~</li>"; 런 각각의 배열을 <li>~</li><li>~</li> 이런식으로 하나의 마크업으로 붙여주는 기능을 한다.
  -const menuId = e.target.closest("li").dataset.menuId; => 데이터 속성을 가져올 때 dataset을 이용해서 가져온다.
  -this.menu = []; 같은 초기화를 하는 이유 : 상태가 어떤 데이터형태로 들어오는지 알 수 있기 위해서 -카테고리별로 저장된 메뉴를 가져오기 위해서는 객체형태로 데이터들이 저장되어 있어야 하겠지? -이벤트 객체를 사용하기 때문에 이벤트를 파라미터로 넘겨줄 수 있다.
  -hong =!hong 이런식으로 하면 버튼을 클릭했을 때 true,false 반복 가능하다.

> step3 요구사항 - 서버와의 통신을 통해 메뉴 관리하기

-fetch('url', option) 메소드 -제일 처음 url인자가 들어가서 요청을 보내면 그 요청을 서버에서 처리하는 역할을 하게 함. -두번째 인자로 option을 받는데 서버에 데이터를 받는건지,생성,수정,삭제를 요청하는건지 구체적인 약속에 대한 내용이 들어간다.
